{
  "version": 3,
  "sources": ["../../src/lib/translation-monad.ts"],
  "sourcesContent": ["import type { TranslationMonad } from '../types.js';\n\n/**\n * Creates a translation monad for handling translation operations in a functional way.\n * Supports both sync and async operations with proper error handling.\n */\nexport function createTranslationMonad<T>(value?: T): TranslationMonad<T> {\n  return {\n    map<U>(fn: (value: T) => U): TranslationMonad<U> {\n      if (value === undefined) {\n        return createTranslationMonad<U>();\n      }\n      try {\n        return createTranslationMonad(fn(value));\n      } catch (error) {\n        console.error('[TSd] Error in monad map:', error);\n        return createTranslationMonad<U>();\n      }\n    },\n\n    flatMap<U>(\n      fn: (value: T) => TranslationMonad<U> | Promise<TranslationMonad<U>>\n    ): TranslationMonad<U> {\n      if (value === undefined) {\n        return createTranslationMonad<U>();\n      }\n\n      try {\n        const result = fn(value);\n        // Handle both sync and async results\n        if (result && typeof (result as any).then === 'function') {\n          // If it's a promise, we need to return an async monad\n          return createAsyncTranslationMonad(\n            (result as Promise<TranslationMonad<U>>).then(m => m.value())\n          ) as TranslationMonad<U>;\n        }\n        return result as TranslationMonad<U>;\n      } catch (error) {\n        console.error('[TSd] Error in monad flatMap:', error);\n        return createTranslationMonad<U>();\n      }\n    },\n\n    getOrElse(defaultValue: T): T {\n      return value ?? defaultValue;\n    },\n\n    value(): T | undefined {\n      return value;\n    },\n  };\n}\n\n/**\n * Creates an async translation monad for handling asynchronous translation operations.\n */\nexport function createAsyncTranslationMonad<T>(\n  promise: Promise<T>\n): TranslationMonad<T> {\n  const asyncValue = promise.catch((error) => {\n    console.error('[TSd] Async monad error:', error);\n    return undefined;\n  });\n\n  return {\n    map<U>(fn: (value: T) => U): TranslationMonad<U> {\n      const mappedPromise = asyncValue.then((val) => {\n        if (val === undefined) return undefined;\n        try {\n          return fn(val);\n        } catch (error) {\n          console.error('[TSd] Error in async monad map:', error);\n          return undefined;\n        }\n      });\n      return createAsyncTranslationMonad(mappedPromise as Promise<U>);\n    },\n\n    flatMap<U>(\n      fn: (value: T) => TranslationMonad<U> | Promise<TranslationMonad<U>>\n    ): TranslationMonad<U> {\n      const flatMappedPromise = asyncValue.then(async (val) => {\n        if (val === undefined) return undefined;\n        try {\n          const result = await fn(val);\n          return result.value();\n        } catch (error) {\n          console.error('[TSd] Error in async monad flatMap:', error);\n          return undefined;\n        }\n      });\n      return createAsyncTranslationMonad(flatMappedPromise as Promise<U>);\n    },\n\n    async getOrElse(defaultValue: T): Promise<T> {\n      const val = await asyncValue;\n      return val ?? defaultValue;\n    },\n\n    async value(): Promise<T | undefined> {\n      return asyncValue;\n    },\n  } as any; // Type assertion needed due to async overrides\n}\n\n/**\n * Utility function to chain multiple translation monads\n */\nexport function chainTranslations<T>(\n  ...monads: TranslationMonad<T>[]\n): TranslationMonad<T[]> {\n  const values = monads.map((m) => m.value()).filter((v) => v !== undefined) as T[];\n  return createTranslationMonad(values.length > 0 ? values : undefined);\n}\n\n/**\n * Utility function to create a failed translation monad\n */\nexport function failedTranslation<T>(error?: Error): TranslationMonad<T> {\n  if (error) {\n    console.error('[TSd] Translation failed:', error);\n  }\n  return createTranslationMonad<T>();\n}\n\n\n\n// Hot reload test\n"],
  "mappings": ";;AAMO,SAAS,uBAA0B,OAAgC;AACxE,SAAO;AAAA,IACL,IAAO,IAA0C;AAC/C,UAAI,UAAU,QAAW;AACvB,eAAO,uBAA0B;AAAA,MACnC;AACA,UAAI;AACF,eAAO,uBAAuB,GAAG,KAAK,CAAC;AAAA,MACzC,SAAS,OAAO;AACd,gBAAQ,MAAM,6BAA6B,KAAK;AAChD,eAAO,uBAA0B;AAAA,MACnC;AAAA,IACF;AAAA,IAEA,QACE,IACqB;AACrB,UAAI,UAAU,QAAW;AACvB,eAAO,uBAA0B;AAAA,MACnC;AAEA,UAAI;AACF,cAAM,SAAS,GAAG,KAAK;AAEvB,YAAI,UAAU,OAAQ,OAAe,SAAS,YAAY;AAExD,iBAAO;AAAA,YACJ,OAAwC,KAAK,OAAK,EAAE,MAAM,CAAC;AAAA,UAC9D;AAAA,QACF;AACA,eAAO;AAAA,MACT,SAAS,OAAO;AACd,gBAAQ,MAAM,iCAAiC,KAAK;AACpD,eAAO,uBAA0B;AAAA,MACnC;AAAA,IACF;AAAA,IAEA,UAAU,cAAoB;AAC5B,aAAO,SAAS;AAAA,IAClB;AAAA,IAEA,QAAuB;AACrB,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA7CgB;AAkDT,SAAS,4BACd,SACqB;AACrB,QAAM,aAAa,QAAQ,MAAM,CAAC,UAAU;AAC1C,YAAQ,MAAM,4BAA4B,KAAK;AAC/C,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AAAA,IACL,IAAO,IAA0C;AAC/C,YAAM,gBAAgB,WAAW,KAAK,CAAC,QAAQ;AAC7C,YAAI,QAAQ,OAAW,QAAO;AAC9B,YAAI;AACF,iBAAO,GAAG,GAAG;AAAA,QACf,SAAS,OAAO;AACd,kBAAQ,MAAM,mCAAmC,KAAK;AACtD,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AACD,aAAO,4BAA4B,aAA2B;AAAA,IAChE;AAAA,IAEA,QACE,IACqB;AACrB,YAAM,oBAAoB,WAAW,KAAK,OAAO,QAAQ;AACvD,YAAI,QAAQ,OAAW,QAAO;AAC9B,YAAI;AACF,gBAAM,SAAS,MAAM,GAAG,GAAG;AAC3B,iBAAO,OAAO,MAAM;AAAA,QACtB,SAAS,OAAO;AACd,kBAAQ,MAAM,uCAAuC,KAAK;AAC1D,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AACD,aAAO,4BAA4B,iBAA+B;AAAA,IACpE;AAAA,IAEA,MAAM,UAAU,cAA6B;AAC3C,YAAM,MAAM,MAAM;AAClB,aAAO,OAAO;AAAA,IAChB;AAAA,IAEA,MAAM,QAAgC;AACpC,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA/CgB;AAoDT,SAAS,qBACX,QACoB;AACvB,QAAM,SAAS,OAAO,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,OAAO,CAAC,MAAM,MAAM,MAAS;AACzE,SAAO,uBAAuB,OAAO,SAAS,IAAI,SAAS,MAAS;AACtE;AALgB;AAUT,SAAS,kBAAqB,OAAoC;AACvE,MAAI,OAAO;AACT,YAAQ,MAAM,6BAA6B,KAAK;AAAA,EAClD;AACA,SAAO,uBAA0B;AACnC;AALgB;",
  "names": []
}
