{
  "version": 3,
  "sources": ["../../src/vite/translation-manager.ts"],
  "sourcesContent": ["import type { TsdConfig, TranslationMap, TranslationEntry, Locale, TranslationMonad } from '../types.js';\nimport { createTranslationMonad, createAsyncTranslationMonad, failedTranslation } from '../lib/translation-monad.js';\nimport { LibreTranslateClient } from '../lib/libretranslate-client.js';\nimport * as path from 'node:path';\nimport { readFile, writeFile } from 'node:fs/promises';\nimport * as crypto from 'node:crypto';\n\nexport function createTranslationManager(config: Required<TsdConfig>) {\n  const translationMap: TranslationMap = {};\n  const cacheFile = path.join(config.cacheDir, 'translations.json');\n  const translator = new LibreTranslateClient(config.translationProvider);\n\n  async function loadCache() {\n    try {\n      const data = await readFile(cacheFile, 'utf-8');\n      const cached = JSON.parse(data) as TranslationMap;\n      Object.assign(translationMap, cached);\n    } catch (error) {\n      // Cache doesn't exist yet, that's fine\n    }\n  }\n\n  async function saveCache() {\n    await writeFile(cacheFile, JSON.stringify(translationMap, null, 2));\n  }\n\n  function generateKey(text: string, native: Locale): string {\n    const hash = crypto.createHash('sha256');\n    hash.update(`${text}:${native}`);\n    return hash.digest('hex').substring(0, 16);\n  }\n\n  function getOrCreateTranslation(\n    text: string,\n    native: Locale,\n    targetLocale: Locale\n  ): TranslationMonad<string> {\n    const key = generateKey(text, native);\n\n    // Create entry if it doesn't exist\n    if (!translationMap[key]) {\n      translationMap[key] = {\n        key,\n        native,\n        text,\n        translations: {\n          [native]: text,\n        },\n      };\n    }\n\n    const entry = translationMap[key];\n\n    // Return existing translation if available\n    if (entry.translations[targetLocale]) {\n      return createTranslationMonad(entry.translations[targetLocale]);\n    }\n\n    // No translation needed for same locale\n    if (native === targetLocale) {\n      return createTranslationMonad(text);\n    }\n\n    // Use async monad for translation\n    const translationPromise = translator.translate(text, native, targetLocale)\n      .then(async (translated) => {\n        if (translated) {\n          entry.translations[targetLocale] = translated;\n          await saveCache();\n          return translated;\n        }\n        return text;\n      })\n      .catch((error) => {\n        console.error('[TSd] Translation error:', error);\n        return text;\n      });\n\n    return createAsyncTranslationMonad(translationPromise);\n  }\n\n  function addTranslationRequest(text: string, native: Locale): TranslationMonad<string> {\n    const key = generateKey(text, native);\n\n    if (!translationMap[key]) {\n      translationMap[key] = {\n        key,\n        native,\n        text,\n        translations: {\n          [native]: text,\n        },\n      };\n\n      // Trigger translation for all supported locales using monads\n      for (const locale of config.supportedLocales) {\n        if (locale !== native) {\n          // Fire and forget - translations happen in background\n          const monad = getOrCreateTranslation(text, native, locale);\n          const value = monad.value();\n          if (value instanceof Promise) {\n            value\n              .then((result) => {\n                if (!result) {\n                  console.warn(`[TSd] Failed to translate \"${text}\" to ${locale}`);\n                }\n              })\n              .catch(console.error);\n          }\n        }\n      }\n    }\n\n    return createTranslationMonad(key);\n  }\n\n  async function getTranslations(): Promise<TranslationMap> {\n    return { ...translationMap };\n  }\n\n  function getTranslation(key: string, locale: Locale): TranslationMonad<string> {\n    const entry = translationMap[key];\n    const translation = entry?.translations[locale] || entry?.text;\n    return translation ? createTranslationMonad(translation) : failedTranslation();\n  }\n\n  // Helper function to get a translation synchronously (for backwards compatibility)\n  async function getTranslationValue(\n    text: string,\n    native: Locale,\n    targetLocale: Locale\n  ): Promise<string> {\n    const monad = getOrCreateTranslation(text, native, targetLocale);\n    return monad.getOrElse(text);\n  }\n\n  return {\n    loadCache,\n    saveCache,\n    getOrCreateTranslation,\n    getTranslationValue,\n    addTranslationRequest,\n    getTranslations,\n    getTranslation,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
